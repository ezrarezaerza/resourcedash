var dateFormat="YYYY-MM-DD",timeFormat="HH:mm A";

function GetTime(){
  var prettyTime=moment().format(window.timeFormat);
  document.getElementById('clockbox').innerHTML=prettyTime;
  CheckDayCountdown();
}

function GetDate(){
  var dayOfWeek=moment().format('dddd'),
  prettyDate=moment().format(window.dateFormat);
  document.getElementById('daybox').innerHTML=dayOfWeek;
  document.getElementById('datebox').innerHTML=prettyDate;
}

function CheckDayCountdown(){
  CountdownDay();
}

function CountdownDay(){
  var now=new Date(),
  todayStart=new Date(now.getFullYear(),now.getMonth(),now.getDate()),
  tomorrowStart=new Date(now.getFullYear(),now.getMonth(),now.getDate()+1),
  progressMS=now-todayStart,
  totalDayMS=24*60*60*1000,
  dayProgressPCT=progressMS/totalDayMS*100,
  prettyDayPCT=Math.floor(dayProgressPCT),
  remainingMS=tomorrowStart-now,
  remainingHours=Math.floor(remainingMS/(60*60*1000));
 
  document.getElementById('countdown-day-amount').innerHTML=prettyDayPCT+"%";
  document.getElementById('day-progress-fill').style.width = prettyDayPCT + '%';
  document.getElementById('day-remaining').innerHTML = remainingHours + " hours left";
  setTimeout(CountdownDay,1000);
}

function CountdownMonthYear(){
  var now=new Date(),
  monthStart=new Date(now.getFullYear(),now.getMonth(),1),
  nextMonthStart=new Date(now.getFullYear(),now.getMonth()+1,1),
  yearStart=new Date(now.getFullYear(),0,1),
  nextYearStart=new Date(now.getFullYear()+1,0,1),
  progressMonthMS=now-monthStart,
  totalMonthMS=new Date(now.getFullYear(),now.getMonth()+1,0).getDate()*24*60*60*1000,
  monthProgressPCT=progressMonthMS/totalMonthMS*100,
  prettyMonthPCT=Math.floor(monthProgressPCT),
  progressYearMS=now-yearStart,
  totalYearMS=365*24*60*60*1000,
  yearProgressPCT=progressYearMS/totalYearMS*100,
  prettyYearPCT=Math.floor(yearProgressPCT),
  remainingMonthMS=nextMonthStart-now,
  remainingYearMS=nextYearStart-now,
  remainingDays=Math.floor(remainingMonthMS/(24*60*60*1000)),
  remainingMonths=Math.floor(remainingYearMS/(30*24*60*60*1000));
 
  document.getElementById('countdown-month-amount').innerHTML=prettyMonthPCT+"%";
  document.getElementById('countdown-year-amount').innerHTML=prettyYearPCT+"%";
  document.getElementById('month-progress-fill').style.width = prettyMonthPCT + '%';
  document.getElementById('year-progress-fill').style.width = prettyYearPCT + '%';
  document.getElementById('month-remaining').innerHTML = remainingDays + " days left";
  document.getElementById('year-remaining').innerHTML = remainingMonths + " months left";
  setTimeout(CountdownMonthYear,1000);
}

function SetDateTimeFormat(){
  dateFormat=localStorage.getItem('user-date-format')||"MMM D, YYYY";
  GetDate();
  timeFormat=localStorage.getItem('user-time-format')||"h:mm:ss A";
  GetTime();
  setInterval(GetTime,1000);
  setInterval(CountdownDay,900000);
}

function parseMarkdown(text) {
  if (!text) return '';
  
  text = text.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank">$1</a>');
  
  // Checkboxes (markdown)
  text = text.replace(/^- \[x\] (.*)$/gim, '<div class="checkbox-line"><label><input type="checkbox" checked> <span class="checkbox-label" style="text-decoration: line-through;">$1</span></label></div>');
  text = text.replace(/^- \[ \] (.*)$/gim, '<div class="checkbox-line"><label><input type="checkbox"> <span class="checkbox-label">$1</span></label></div>');
  
  // Bold
  text = text.replace(/\*\*([^*]+)\*\*/g, '<b>$1</b>');
  // Italic
  text = text.replace(/\*([^*]+)\*/g, '<i>$1</i>');
  
  const lines = text.split('\n');
  let inList = false;
  let result = '';
  
  for (let i = 0; i < lines.length; i++) {
    let line = lines[i].trim();
    if (line.startsWith('- ') && !line.match(/^- \[[ x]\]/)) {
      if (!inList) {
        result += '<ul>';
        inList = true;
      }
      result += '<li>' + line.substring(2) + '</li>';
    } else {
      if (inList) {
        result += '</ul>';
        inList = false;
      }
      if (line && !line.startsWith('<div class="checkbox-line">')) result += line + '<br>';
      else if (line.startsWith('<div class="checkbox-line">')) result += line;
    }
  }
  
  if (inList) {
    result += '</ul>';
  }
  
  return result.trim();
}

let masonryInstance = null;
let masonryInitialized = false;
let pendingNotes = [];
let editingNoteId = null;
let currentLabels = new Set();
let currentProgress = null;
let currentMatrix = null;

// Global variables for DOM elements
let noteInput, noteTitle, noteContent, noteActions, labelInput, newLabelInput;
let labelContainer, addLabelBtn, addListBtn, addLinkBtn, saveNote, cancelNote;

function waitForMasonry(callback, maxAttempts = 20) {
  let attempts = 0;
  
  function checkMasonry() {
    if (typeof Masonry !== 'undefined') {
      console.log('Masonry loaded successfully');
      masonryInitialized = true;
      callback();
    } else if (attempts < maxAttempts) {
      attempts++;
      console.log(`Waiting for Masonry... Attempt ${attempts}`);
      setTimeout(checkMasonry, 200);
    } else {
      console.error('Masonry failed to load after multiple attempts');
    }
  }
  
  checkMasonry();
}

function initMasonry() {
  if (!masonryInitialized) {
    console.warn('Masonry not yet initialized, will retry initialization');
    waitForMasonry(() => {
      initMasonry();
      processPendingNotes();
    });
    return null;
  }

  const grid = document.querySelector('.notes-grid');
  if (!grid) {
    console.error('Notes grid not found');
    return null;
  }
  
  try {
    // Destroy existing instance if it exists
    if (masonryInstance) {
      masonryInstance.destroy();
    }
    
    // Create new instance
    masonryInstance = new Masonry(grid, {
    itemSelector: '.note-card',
    columnWidth: '.note-card',
    percentPosition: true,
      transitionDuration: '0.2s',
      initLayout: true
    });
    
    console.log('Masonry initialized successfully');
    return masonryInstance;
  } catch (error) {
    console.error('Error initializing Masonry:', error);
    return null;
  }
}

function addNoteToMasonry(noteCard) {
  if (!masonryInitialized || !masonryInstance) {
    console.log('Masonry not ready, queueing note');
    pendingNotes.push(noteCard);
    return;
  }
  
  try {
    const grid = document.querySelector('.notes-grid');
    if (!grid) {
      console.error('Notes grid not found');
      return;
    }
    
    // Add to the beginning of the grid
    grid.insertBefore(noteCard, grid.firstChild);
    masonryInstance.prepended(noteCard);
    masonryInstance.layout();
    console.log('Note added to Masonry successfully');
  } catch (error) {
    console.error('Error adding note to Masonry:', error);
  }
}

function processPendingNotes() {
  if (!masonryInitialized || !masonryInstance) {
    console.log('Masonry not ready for processing pending notes');
    return;
  }
  
  console.log(`Processing ${pendingNotes.length} pending notes`);
  const grid = document.querySelector('.notes-grid');
  
  while (pendingNotes.length > 0) {
    const noteCard = pendingNotes.shift();
    grid.appendChild(noteCard);
    masonryInstance.appended(noteCard);
  }
  
  masonryInstance.layout();
}

function loadNotes() {
  console.log('Loading notes...');
  chrome.storage.local.get(['notes'], function(result) {
    const notes = result.notes || [];
    const grid = document.querySelector('.notes-grid');
    
    if (!grid) {
      console.error('Notes grid not found during load');
      return;
    }
    
    // Clear existing notes
    grid.innerHTML = '';
    
    // Create all note cards first
    const noteCards = notes.map(note => createNoteCard(note));
    
    // Add notes to grid in the same order as they are stored (newest first)
    noteCards.forEach(noteCard => {
      if (masonryInitialized && masonryInstance) {
        grid.appendChild(noteCard);
        masonryInstance.appended(noteCard);
      } else {
        pendingNotes.push(noteCard);
      }
    });
    
    // Layout Masonry after all notes are added
    if (masonryInstance) {
      masonryInstance.layout();
    }
    
    // Process any pending notes
    processPendingNotes();
  });
}

function getIconForLabel(label) {
  const iconMap = {
    work: 'fa-briefcase',
    task: 'fa-tasks',
    home: 'fa-home',
    shopping: 'fa-shopping-cart',
    study: 'fa-book',
    meeting: 'fa-users',
    idea: 'fa-lightbulb-o',
    reminder: 'fa-bell',
    travel: 'fa-plane',
    health: 'fa-heartbeat',
    fitness: 'fa-bicycle',
    food: 'fa-cutlery',
    music: 'fa-music',
    movie: 'fa-film',
    code: 'fa-code',
    bug: 'fa-bug',
    feature: 'fa-star',
    design: 'fa-paint-brush',
    writing: 'fa-pencil',
    email: 'fa-envelope',
    call: 'fa-phone',
    urgent: 'fa-exclamation-circle',
    important: 'fa-flag',
    personal: 'fa-user',
    project: 'fa-folder',
    finance: 'fa-money',
    money: 'fa-money',
    budget: 'fa-calculator',
    payment: 'fa-credit-card',
    calendar: 'fa-calendar',
    schedule: 'fa-clock-o',
    appointment: 'fa-calendar-check-o',
    document: 'fa-file-text',
    file: 'fa-file',
    pdf: 'fa-file-pdf-o',
    word: 'fa-file-word-o',
    excel: 'fa-file-excel-o',
    presentation: 'fa-file-powerpoint-o',
    image: 'fa-image',
    photo: 'fa-camera',
    video: 'fa-video-camera',
    audio: 'fa-volume-up',
    chat: 'fa-comments',
    message: 'fa-comment',
    social: 'fa-share-alt',
    link: 'fa-link',
    website: 'fa-globe',
    search: 'fa-search',
    location: 'fa-map-marker',
    address: 'fa-location-arrow',
    car: 'fa-car',
    transport: 'fa-bus',
    book: 'fa-book',
    read: 'fa-book',
    library: 'fa-university',
    education: 'fa-graduation-cap',
    research: 'fa-microscope',
    science: 'fa-flask',
    lab: 'fa-flask',
    tool: 'fa-wrench',
    settings: 'fa-cog',
    security: 'fa-shield',
    lock: 'fa-lock',
    key: 'fa-key',
    gift: 'fa-gift',
    present: 'fa-gift',
    birthday: 'fa-birthday-cake',
    party: 'fa-glass',
    celebration: 'fa-glass',
    game: 'fa-gamepad',
    sport: 'fa-futbol-o',
    weather: 'fa-cloud',
    temperature: 'fa-thermometer',
    sun: 'fa-sun-o',
    moon: 'fa-moon-o',
    chart: 'fa-bar-chart',
    graph: 'fa-line-chart',
    stats: 'fa-pie-chart',
    analytics: 'fa-area-chart',
    trophy: 'fa-trophy',
    award: 'fa-certificate',
    medal: 'fa-medal',
    heart: 'fa-heart',
    love: 'fa-heart',
    favorite: 'fa-star',
    bookmark: 'fa-bookmark',
    save: 'fa-save',
    print: 'fa-print',
    camera: 'fa-camera',
    photo: 'fa-camera',
    wifi: 'fa-wifi',
    network: 'fa-sitemap',
    cloud: 'fa-cloud',
    upload: 'fa-upload',
    download: 'fa-download',
    sync: 'fa-refresh',
    update: 'fa-refresh',
    trash: 'fa-trash',
    delete: 'fa-trash',
    archive: 'fa-archive',
    box: 'fa-archive',
    tag: 'fa-tag',
    label: 'fa-tags',
    category: 'fa-sitemap',
    default: 'fa-sticky-note-o'
  };

  label = label.toLowerCase();
  
  for (const [key, icon] of Object.entries(iconMap)) {
    if (label.includes(key)) {
      return icon;
    }
  }
  
  return iconMap.default;
}

function getProgressIcon(progress) {
  const icons = {
    'new': 'fa-plus-circle',
    'in-progress': 'fa-spinner fa-spin',
    'completed': 'fa-check-circle'
  };
  return icons[progress] || 'fa-circle';
}

function getProgressText(progress) {
  const texts = {
    'new': 'New Task',
    'in-progress': 'In Progress',
    'completed': 'Completed'
  };
  return texts[progress] || progress;
}

function getMatrixIcon(matrix) {
  const icons = {
    'urgent-important': 'fa-exclamation-circle',
    'important': 'fa-star',
    'urgent': 'fa-clock-o',
    'neither': 'fa-circle-o'
  };
  return icons[matrix] || 'fa-circle-o';
}

function getMatrixText(matrix) {
  const texts = {
    'urgent-important': 'Urgent & Important',
    'important': 'Important',
    'urgent': 'Urgent',
    'neither': 'Neither'
  };
  return texts[matrix] || matrix;
}

function createNoteCard(note) {
  const noteElement = document.createElement('div');
  noteElement.className = `note-card ${note.progress || 'note'}`;
  noteElement.id = note.id;
  
  const icon = note.labels && note.labels.length > 0 
    ? getIconForLabel(note.labels[0])
    : 'fa-sticky-note-o';
  
  const labelHtml = note.labels ? note.labels.map(label => 
    `<span class="note-label" data-label="${label}">
      ${label}
      <i class="fa fa-times"></i>
    </span>`
  ).join('') : '';

  // Only show progress indicator if progress is set
  const progressHtml = note.progress ? `
    <div class="task-progress">
      <div class="progress-indicator ${note.progress}">
        <i class="fa ${getProgressIcon(note.progress)}"></i>
        <span>${getProgressText(note.progress)}</span>
        ${note.progress === 'completed' && note.completedAt ? 
          `<span class="completion-date">Completed ${moment(note.completedAt).fromNow()}</span>` : ''}
        ${note.progress === 'new' && note.created ? 
          `<span class="completion-date">Created ${moment(note.created).fromNow()}</span>` : ''}
        ${note.progress === 'in-progress' && note.modified ? 
          `<span class="completion-date">Started ${moment(note.modified).fromNow()}</span>` : ''}
      </div>
    </div>
  ` : '';

  // Add matrix indicator if matrix is set
  const matrixHtml = note.matrix ? `
    <div class="matrix-indicator ${note.matrix}">
      <i class="fa ${getMatrixIcon(note.matrix)}"></i>
      <span>${getMatrixText(note.matrix)}</span>
    </div>
  ` : '';

  // Show Archive or Unarchive button based on note.archived
  const archiveBtnHtml = note.archived
    ? `<button class="note-card-action" title="Unarchive"><i class="fa fa-inbox"></i></button>`
    : `<button class="note-card-action" title="Archive"><i class="fa fa-archive"></i></button>`;
  
  noteElement.innerHTML = `
    <div class="note-card-title">
      <i class="fa ${icon}"></i>
      ${note.title}
    </div>
    <div class="note-card-content">${parseMarkdown(note.content)}</div>
    ${progressHtml}
    ${matrixHtml}
    <div class="note-labels">${labelHtml}</div>
    <div class="note-card-footer">
      <button class="note-card-action" title="Edit">
        <i class="fa fa-pencil"></i>
      </button>
      <button class="note-card-action" title="Delete">
        <i class="fa fa-trash-o"></i>
      </button>
      ${archiveBtnHtml}
    </div>
  `;

  // Add click event listeners for the buttons
  const editButton = noteElement.querySelector('[title="Edit"]');
  const deleteButton = noteElement.querySelector('[title="Delete"]');
  const archiveButton = noteElement.querySelector('[title="Archive"]');
  const unarchiveButton = noteElement.querySelector('[title="Unarchive"]');

  if (editButton) {
    editButton.addEventListener('click', function() {
      handleEditNote(note);
    });
  }

  if (deleteButton) {
    deleteButton.addEventListener('click', function() {
      handleDeleteNote(noteElement, note.id);
    });
  }

  if (archiveButton) {
    archiveButton.addEventListener('click', function() {
      handleArchiveNote(noteElement, note.id);
    });
  }

  if (unarchiveButton) {
    unarchiveButton.addEventListener('click', function() {
      handleUnarchiveNote(noteElement, note.id);
    });
  }
  
  return noteElement;
}

function handleEditNote(note) {
  editingNoteId = note.id;
  
  // Update the note input UI
  noteInput.classList.add('editing');
  noteTitle.value = note.title || '';
  noteContent.value = note.content || '';
  currentLabels = new Set(note.labels || []);
  currentProgress = note.progress;
  currentMatrix = note.matrix;
  
  // Update progress buttons
  document.querySelectorAll('.progress-option').forEach(btn => {
    btn.classList.remove('selected');
    if (btn.dataset.status === currentProgress) {
      btn.classList.add('selected');
    }
  });

  // Update matrix buttons
  document.querySelectorAll('.matrix-option').forEach(btn => {
    btn.classList.remove('selected');
    if (btn.dataset.matrix === currentMatrix) {
      btn.classList.add('selected');
    }
  });
  
  // Update labels display
  updateLabelDisplay();
  
  // Expand the note input with animation
  expandNoteInput();
  
  // Focus the title field
  noteTitle.focus();
  
  // Add a visual indicator that we're editing
  const editIndicator = document.createElement('div');
  editIndicator.className = 'edit-indicator';
  editIndicator.innerHTML = '<i class="fa fa-pencil"></i> Editing Note';
  noteInput.insertBefore(editIndicator, noteInput.firstChild);
  
  // Update save button text
  saveNote.innerHTML = '<i class="fa fa-save"></i> Save Changes';
  
  // Scroll the note input into view
  noteInput.scrollIntoView({ behavior: 'smooth', block: 'start' });
}

function handleDeleteNote(noteElement, noteId) {
  if (!window.confirm('Are you sure you want to delete this note? This action cannot be undone.')) return;
  chrome.storage.local.get(['notes'], function(result) {
    let notes = result.notes || [];
    notes = notes.filter(note => note.id !== noteId);
    chrome.storage.local.set({ notes: notes }, function() {
      if (masonryInstance) {
        masonryInstance.remove(noteElement);
        masonryInstance.layout();
      }
    });
  });
}

function handleArchiveNote(noteElement, noteId) {
  if (!window.confirm('Archive this note? You can restore it from the Archived menu.')) return;
  chrome.storage.local.get(['notes'], function(result) {
    let notes = result.notes || [];
    notes = notes.map(note => note.id === noteId ? { ...note, archived: true, modified: new Date().toISOString() } : note);
    chrome.storage.local.set({ notes: notes }, function() {
      if (masonryInstance) {
        masonryInstance.remove(noteElement);
        masonryInstance.layout();
      }
    });
  });
}

function handleUnarchiveNote(noteElement, noteId) {
  if (!window.confirm('Unarchive this note? It will return to your active notes.')) return;
  chrome.storage.local.get(['notes'], function(result) {
    let notes = result.notes || [];
    notes = notes.map(note => note.id === noteId ? { ...note, archived: false, modified: new Date().toISOString() } : note);
    chrome.storage.local.set({ notes: notes }, function() {
      if (masonryInstance) {
        masonryInstance.remove(noteElement);
        masonryInstance.layout();
      }
    });
  });
}

function insertAtCursor(textarea, text) {
  const start = textarea.selectionStart;
  const end = textarea.selectionEnd;
  const before = textarea.value.substring(0, start);
  const after = textarea.value.substring(end);
  
  textarea.value = before + text + after;
  textarea.selectionStart = textarea.selectionEnd = start + text.length;
  textarea.focus();
}

function showLinkDialog(textarea) {
  const dialog = document.getElementById('link-dialog');
  const selectedText = textarea.value.substring(textarea.selectionStart, textarea.selectionEnd);
  
  document.getElementById('link-text').value = selectedText;
  document.getElementById('link-url').value = '';
  
  const rect = textarea.getBoundingClientRect();
  dialog.style.top = rect.bottom + 'px';
  dialog.style.left = rect.left + 'px';
  dialog.style.display = 'block';
  
  document.getElementById('link-text').focus();
}

function updateLabelDisplay() {
  if (!labelContainer) return;
  
  labelContainer.innerHTML = Array.from(currentLabels).map(label => `
    <span class="note-label" data-label="${label}">
      ${label}
      <i class="fa fa-times"></i>
    </span>
  `).join('');
}

function expandNoteInput() {
  noteInput.classList.add('expanded');
  noteContent.style.display = 'block';
  noteActions.style.display = 'flex';
  labelContainer.style.display = 'flex';
  document.querySelector('.task-progress').style.display = 'flex';
  document.querySelector('.eisenhower-matrix').style.display = 'block';
  
  // Add animation class
  noteInput.classList.add('animate-expand');
  
  // Remove animation class after animation completes
  setTimeout(() => {
    noteInput.classList.remove('animate-expand');
  }, 300);
}

function collapseNoteInput() {
  // Remove edit indicator if it exists
  const editIndicator = noteInput.querySelector('.edit-indicator');
  if (editIndicator) {
    editIndicator.remove();
  }
  
  // Remove editing class
  noteInput.classList.remove('editing');
  
  // Reset save button text
  saveNote.innerHTML = '<i class="fa fa-save"></i> Save Note';
  
  noteInput.classList.remove('expanded');
  noteContent.style.display = 'none';
  noteActions.style.display = 'none';
  labelInput.style.display = 'none';
  labelContainer.style.display = 'none';
  document.querySelector('.task-progress').style.display = 'none';
  document.querySelector('.eisenhower-matrix').style.display = 'none';
  document.querySelectorAll('.progress-option').forEach(btn => btn.classList.remove('selected'));
  document.querySelectorAll('.matrix-option').forEach(btn => btn.classList.remove('selected'));
  noteTitle.value = '';
  noteContent.value = '';
  currentLabels.clear();
  currentProgress = null;
  currentMatrix = null;
  updateLabelDisplay();
  editingNoteId = null;
}

window.onload = function() {
  // Initialize DOM elements
  noteInput = document.getElementById('note-input');
  noteTitle = noteInput.querySelector('.note-title');
  noteContent = noteInput.querySelector('.note-content');
  noteActions = noteInput.querySelector('.note-actions');
  labelInput = noteInput.querySelector('.label-input');
  newLabelInput = noteInput.querySelector('.new-label-input');
  labelContainer = noteInput.querySelector('.note-labels');
  addLabelBtn = noteInput.querySelector('[title="Add Label"]');
  addListBtn = noteInput.querySelector('[title="Add List Item"]');
  addLinkBtn = noteInput.querySelector('[title="Add Link"]');
  saveNote = noteInput.querySelector('.save-note');
  cancelNote = noteInput.querySelector('.cancel-note');
  // New: Bold, Italic, Checkbox buttons
  const boldBtn = document.getElementById('bold-btn');
  const italicBtn = document.getElementById('italic-btn');
  const checkboxBtn = document.getElementById('checkbox-btn');

  // Insert markdown at cursor
  function insertMarkdown(textarea, before, after) {
    const start = textarea.selectionStart;
    const end = textarea.selectionEnd;
    const selected = textarea.value.substring(start, end);
    const beforeText = textarea.value.substring(0, start);
    const afterText = textarea.value.substring(end);
    textarea.value = beforeText + before + selected + after + afterText;
    textarea.selectionStart = textarea.selectionEnd = start + before.length + selected.length + after.length;
    textarea.focus();
  }

  if (boldBtn) {
    boldBtn.addEventListener('click', function() {
      insertMarkdown(noteContent, '**', '**');
    });
  }
  if (italicBtn) {
    italicBtn.addEventListener('click', function() {
      insertMarkdown(noteContent, '*', '*');
    });
  }
  if (checkboxBtn) {
    checkboxBtn.addEventListener('click', function() {
      insertAtCursor(noteContent, '\n- [ ] ');
    });
  }

  // Add CSS for enhanced progress indicators and other styles
  const style = document.createElement('style');
  style.textContent = `
    .note-input.editing {
      border: 2px solid #4CAF50;
      box-shadow: 0 0 10px rgba(76, 175, 80, 0.3);
    }
    
    .edit-indicator {
      background: #4CAF50;
      color: white;
      padding: 5px 10px;
      border-radius: 4px;
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      gap: 5px;
    }
    
    .note-input.animate-expand {
      animation: expandNote 0.3s ease-out;
    }
    
    @keyframes expandNote {
      from {
        transform: scale(0.98);
        opacity: 0.8;
      }
      to {
        transform: scale(1);
        opacity: 1;
      }
    }

    .task-progress {
      margin: 10px 0;
      border-radius: 6px;
    }

    .progress-indicator {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 12px;
      border-radius: 4px;
      font-size: 0.9em;
      font-weight: 500;
      transition: all 0.2s ease;
    }

    .progress-indicator i {
      font-size: 1.1em;
    }

    .progress-indicator.new {
      background: #e3f2fd;
      color: #1976d2;
    }

    .progress-indicator.in-progress {
      background: #ebe0ff;
      color: #7c3aed;
    }

    .progress-indicator.completed {
      background: #e8f5e9;
      color: #388e3c;
    }

    .completion-date {
      margin-left: auto;
      font-size: 0.85em;
      opacity: 0.8;
    }

    .progress-options {
      display: flex;
      gap: 8px;
      margin: 10px 0;
    }

    .progress-option {
      flex: 1;
      padding: 8px 12px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.9em;
      font-weight: 500;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
    }

    .progress-option i {
      font-size: 1.1em;
    }

    .progress-option.new {
      background: #e3f2fd;
      color: #1976d2;
    }

    .progress-option.in-progress {
      background: #fff3e0;
      color: #f57c00;
    }

    .progress-option.completed {
      background: #e8f5e9;
      color: #388e3c;
    }

    .progress-option:hover {
      filter: brightness(0.95);
    }

    .progress-option.selected {
      box-shadow: 0 0 0 2px currentColor;
    }

    .note-card {
      transition: all 0.2s ease;
    }

    .note-card:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }

    .note-card.completed {
      opacity: 0.8;
    }

    .note-card.completed:hover {
      opacity: 1;
    }

    .matrix-indicator {
      background: rgba(0, 0, 0, 0.03);
      padding: 6px 12px;
      border-radius: 4px;
      font-size: 0.9em;
      font-weight: 500;
      transition: all 0.2s ease;
    }

    .matrix-indicator i {
      font-size: 1.1em;
    }

    .matrix-indicator.urgent-important {
      background: #fee2e2;
      color: #dc2626;
    }

    .matrix-indicator.important {
      background: #fef9c3;
      color: #ca8a04;
    }

    .matrix-indicator.urgent {
      background: #ffedd5;
      color: #ea580c;
    }

    .matrix-indicator.neither {
      background: #e5e7eb;
      color: #4b5563;
    }

    .matrix-indicator:hover {
      filter: brightness(0.95);
    }

    .matrix-indicator.selected {
      box-shadow: 0 0 0 2px currentColor;
    }
  `;
  document.head.appendChild(style);

  SetDateTimeFormat();
  CountdownMonthYear();
  
  const lightThemeBtn = document.getElementById('light-theme');
  const darkThemeBtn = document.getElementById('dark-theme');
  
  const savedTheme = localStorage.getItem('theme');
  if (savedTheme === 'dark') {
    document.body.classList.add('dark-theme');
    lightThemeBtn.classList.remove('active');
    darkThemeBtn.classList.add('active');
  }
  
  lightThemeBtn.addEventListener('click', () => {
    document.body.classList.remove('dark-theme');
    localStorage.setItem('theme', 'light');
    lightThemeBtn.classList.add('active');
    darkThemeBtn.classList.remove('active');
  });
  
  darkThemeBtn.addEventListener('click', () => {
    document.body.classList.add('dark-theme');
    localStorage.setItem('theme', 'dark');
    lightThemeBtn.classList.remove('active');
    darkThemeBtn.classList.add('active');
  });

  let allLabels = new Set();

  document.querySelectorAll('.progress-option').forEach(btn => {
    const status = btn.dataset.status;
    btn.innerHTML = `<i class="fa ${getProgressIcon(status)}"></i> ${getProgressText(status)}`;
    
    btn.addEventListener('click', () => {
      document.querySelectorAll('.progress-option').forEach(b => b.classList.remove('selected'));
      btn.classList.add('selected');
      currentProgress = status;
    });
  });

  function addLabel(label) {
    label = label.trim().toLowerCase();
    if (label && !currentLabels.has(label)) {
      currentLabels.add(label);
      allLabels.add(label);
      updateLabelDisplay();
      newLabelInput.value = '';
    }
  }

  function saveCurrentNote() {
    const title = noteTitle.value.trim();
    const content = noteContent.value.trim();
    
    if (title || content) {
      const note = {
        id: editingNoteId || 'note-' + Date.now(),
        title,
        content,
        labels: Array.from(currentLabels),
        created: editingNoteId ? null : new Date().toISOString(),
        modified: new Date().toISOString()
      };
      
      // Only add progress and completedAt if progress is selected
      if (currentProgress) {
        note.progress = currentProgress;
        if (currentProgress === 'completed') {
          note.completedAt = new Date().toISOString();
        }
      }

      // Add matrix if selected
      if (currentMatrix) {
        note.matrix = currentMatrix;
      }

      // Get existing notes
      chrome.storage.local.get(['notes'], function(result) {
        let notes = result.notes || [];
        
        if (editingNoteId) {
          // Update existing note
          const existingNote = notes.find(n => n.id === editingNoteId);
          if (existingNote) {
            note.created = existingNote.created;
            // Only update completedAt if status changed to completed
            if (existingNote.progress !== 'completed' && note.progress === 'completed') {
              note.completedAt = new Date().toISOString();
            } else if (note.progress) {
              note.completedAt = existingNote.completedAt;
            }
            // Update the note while maintaining its position
            notes = notes.map(n => n.id === editingNoteId ? note : n);
          }
        } else {
          // Add new note at the beginning of the array
          notes = [note, ...notes];
        }
        
        // Save updated notes
        chrome.storage.local.set({ notes: notes }, function() {
      const noteCard = createNoteCard(note);
      if (editingNoteId) {
        const oldCard = document.getElementById(editingNoteId);
        oldCard.replaceWith(noteCard);
            addNoteToMasonry(noteCard);
      } else {
            addNoteToMasonry(noteCard);
      }
      
      collapseNoteInput();
      currentProgress = null;
          currentMatrix = null;
        });
      });
    }
  }

  noteTitle.addEventListener('focus', expandNoteInput);

  addListBtn.addEventListener('click', () => {
    insertAtCursor(noteContent, '\n- ');
  });

  addLinkBtn.addEventListener('click', () => {
    showLinkDialog(noteContent);
  });

  document.getElementById('add-link').addEventListener('click', () => {
    const text = document.getElementById('link-text').value.trim();
    const url = document.getElementById('link-url').value.trim();
    
    if (url) {
      const linkText = text || url;
      insertAtCursor(noteContent, `[${linkText}](${url})`);
    }
    
    document.getElementById('link-dialog').style.display = 'none';
  });

  document.getElementById('cancel-link').addEventListener('click', () => {
    document.getElementById('link-dialog').style.display = 'none';
  });

  addLabelBtn.addEventListener('click', () => {
    labelInput.style.display = labelInput.style.display === 'block' ? 'none' : 'block';
    if (labelInput.style.display === 'block') {
      newLabelInput.focus();
    }
  });

  newLabelInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      addLabel(newLabelInput.value);
    }
  });

  labelContainer.addEventListener('click', (e) => {
    if (e.target.tagName === 'I') {
      const label = e.target.closest('.note-label').dataset.label;
      currentLabels.delete(label);
      updateLabelDisplay();
    }
  });

  cancelNote.addEventListener('click', collapseNoteInput);
  saveNote.addEventListener('click', saveCurrentNote);

  // Add matrix option click handlers
  document.querySelectorAll('.matrix-option').forEach(btn => {
    btn.addEventListener('click', () => {
      document.querySelectorAll('.matrix-option').forEach(b => b.classList.remove('selected'));
      btn.classList.add('selected');
      currentMatrix = btn.dataset.matrix;
    });
  });

  // Initialize Masonry
  console.log('Window loaded, initializing Masonry...');
  waitForMasonry(function() {
    console.log('Masonry loaded, initializing...');
    masonryInstance = initMasonry();
    loadNotes();
  });

  // Delegate checkbox click events for strikethrough
  // (after notes are rendered)
  document.addEventListener('click', function(e) {
    if (e.target && e.target.matches('.note-card input[type="checkbox"]')) {
      const label = e.target.closest('label').querySelector('.checkbox-label');
      if (label) {
        if (e.target.checked) {
          label.style.textDecoration = 'line-through';
        } else {
          label.style.textDecoration = '';
        }
      }
      // Update the note content in storage
      const noteCard = e.target.closest('.note-card');
      if (noteCard) {
        const noteId = noteCard.id;
        chrome.storage.local.get(['notes'], function(result) {
          let notes = result.notes || [];
          let note = notes.find(n => n.id === noteId);
          if (note) {
            // Update markdown in note.content
            // Find the checkbox line in the markdown and update [ ] <-> [x]
            const lines = note.content.split('\n');
            let idx = 0;
            let found = false;
            for (let i = 0; i < lines.length; i++) {
              if (lines[i].match(/^- \[[ x]\] /)) {
                if (idx === Array.from(noteCard.querySelectorAll('input[type="checkbox"]')).indexOf(e.target)) {
                  lines[i] = e.target.checked
                    ? lines[i].replace('- [ ] ', '- [x] ').replace('- [x] ', '- [x] ')
                    : lines[i].replace('- [x] ', '- [ ] ');
                  found = true;
                  break;
                }
                idx++;
              }
            }
            if (found) {
              note.content = lines.join('\n');
              note.modified = new Date().toISOString();
              chrome.storage.local.set({ notes: notes });
            }
          }
        });
      }
    }
  });
};

// Sidebar Menu Functionality
(function() {
  let sidebar = null, sidebarToggle = null, sidebarClose = null, sidebarOverlay = null;
  let lastFilter = 'all';
  let allNotesCache = [];

  function filterNotes(filter, searchTerm = '') {
    // If cache is empty, get all notes from storage
    if (!allNotesCache.length) {
      chrome.storage.local.get(['notes'], function(result) {
        allNotesCache = result.notes || [];
        applyFilter(filter, searchTerm);
      });
    } else {
      applyFilter(filter, searchTerm);
    }
  }

  function applyFilter(filter, searchTerm) {
    let notes = allNotesCache.slice();
    if (searchTerm) {
      const term = searchTerm.toLowerCase();
      notes = notes.filter(note =>
        (note.title && note.title.toLowerCase().includes(term)) ||
        (note.content && note.content.toLowerCase().includes(term))
      );
      }
    switch (filter) {
      case 'archived':
        notes = notes.filter(note => note.archived);
        break;
      case 'tasks':
        notes = notes.filter(note => note.progress && !note.archived);
        break;
      case 'notes':
        notes = notes.filter(note => !note.progress && !note.archived);
        break;
      case 'urgent-important':
        notes = notes.filter(note => note.matrix === 'urgent-important' && !note.archived);
        break;
      case 'important':
        notes = notes.filter(note => note.matrix === 'important' && !note.archived);
        break;
      case 'urgent':
        notes = notes.filter(note => note.matrix === 'urgent' && !note.archived);
        break;
      case 'new':
        notes = notes.filter(note => note.progress === 'new' && !note.archived);
        break;
      case 'in-progress':
        notes = notes.filter(note => note.progress === 'in-progress' && !note.archived);
        break;
      case 'completed':
        notes = notes.filter(note => note.progress === 'completed' && !note.archived);
        break;
      default:
        // 'all' - show all notes except archived
        notes = notes.filter(note => !note.archived);
        break;
    }
    renderFilteredNotes(notes);
  }

  function renderFilteredNotes(notes) {
    const grid = document.querySelector('.notes-grid');
    if (!grid) return;
    grid.innerHTML = '';
    // Newest first
    notes.sort((a, b) => new Date(b.modified) - new Date(a.modified));
    notes.forEach(note => {
      const noteCard = createNoteCard(note);
      grid.appendChild(noteCard);
      if (masonryInstance) {
        masonryInstance.appended(noteCard);
      }
    });
    if (masonryInstance) {
      masonryInstance.layout();
    }
  }

  function openSidebar() {
    sidebar.classList.add('open');
    sidebarOverlay.style.display = 'block';
    setTimeout(() => { sidebarOverlay.style.opacity = '1'; }, 10);
  }
  function closeSidebar() {
    sidebar.classList.remove('open');
    sidebarOverlay.style.opacity = '0';
    setTimeout(() => { sidebarOverlay.style.display = 'none'; }, 300);
  }

  window.addEventListener('DOMContentLoaded', function() {
    sidebar = document.getElementById('sidebar');
    sidebarToggle = document.getElementById('sidebar-toggle');
    sidebarClose = document.getElementById('sidebar-close');
    sidebarOverlay = document.getElementById('sidebar-overlay');
    const menuItems = document.querySelectorAll('.sidebar-menu-item');
    const searchInput = document.getElementById('sidebar-search-input');

    if (!sidebar || !sidebarToggle || !sidebarClose || !sidebarOverlay) return;

    sidebarToggle.addEventListener('click', openSidebar);
    sidebarClose.addEventListener('click', closeSidebar);
    sidebarOverlay.addEventListener('click', closeSidebar);

    // Menu item click
    menuItems.forEach(btn => {
      btn.addEventListener('click', function() {
        menuItems.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        lastFilter = btn.dataset.filter;
        filterNotes(lastFilter, searchInput.value);
        closeSidebar();
      });
    });

    // Search input
    searchInput.addEventListener('input', function() {
      filterNotes(lastFilter, searchInput.value);
    });

    // Initial cache load
    chrome.storage.local.get(['notes'], function(result) {
      allNotesCache = result.notes || [];
    });
  });

  // When notes are updated (e.g., new note added), refresh cache
  chrome.storage.onChanged.addListener(function(changes, area) {
    if (area === 'local' && changes.notes) {
      allNotesCache = changes.notes.newValue || [];
      // If a filter is active, re-apply it
      const searchInput = document.getElementById('sidebar-search-input');
      if (searchInput) {
        filterNotes(lastFilter, searchInput.value);
      }
    }
  });
})();

// --- Local Audio Music Player Modal Functionality with IndexedDB ---
(function() {
  let modal, openBtn, closeBtn, songTitle, progressBar, currentTime, duration, playBtn, prevBtn, nextBtn, volumeBar, volumeLabel, fileInput, playlistEl, sortBtn, audio;
  let minimizeBtn, maximizeBtn;
  let playlist = [];
  let currentIdx = 0;
  let isPlaying = false;
  let progressInterval = null;
  let isDragging = false, dragOffsetX = 0, dragOffsetY = 0;
  let lastPosition = null;
  let db = null;
  let objectUrls = {};
  let shuffleBtn, repeatBtn;
  let shuffleMode = false;
  let repeatMode = 0; // 0: off, 1: repeat all, 2: repeat one
  let shuffledOrder = [];

  // IndexedDB helpers
  function openDB() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open('MusicPlayerDB', 1);
      request.onupgradeneeded = function(e) {
        const db = e.target.result;
        if (!db.objectStoreNames.contains('audioFiles')) {
          db.createObjectStore('audioFiles', { keyPath: 'id' });
        }
      };
      request.onsuccess = function(e) { resolve(e.target.result); };
      request.onerror = function(e) { reject(e.target.error); };
    });
  }
  function addFileToDB(id, name, file) {
    return new Promise((resolve, reject) => {
      const tx = db.transaction('audioFiles', 'readwrite');
      const store = tx.objectStore('audioFiles');
      store.put({ id, name, file });
      tx.oncomplete = () => resolve();
      tx.onerror = e => reject(e.target.error);
    });
  }
  function getFileFromDB(id) {
    return new Promise((resolve, reject) => {
      const tx = db.transaction('audioFiles', 'readonly');
      const store = tx.objectStore('audioFiles');
      const req = store.get(id);
      req.onsuccess = () => resolve(req.result);
      req.onerror = e => reject(e.target.error);
    });
  }
  function deleteFileFromDB(id) {
    return new Promise((resolve, reject) => {
      const tx = db.transaction('audioFiles', 'readwrite');
      const store = tx.objectStore('audioFiles');
      store.delete(id);
      tx.oncomplete = () => resolve();
      tx.onerror = e => reject(e.target.error);
    });
  }
  function getAllFilesFromDB() {
    return new Promise((resolve, reject) => {
      const tx = db.transaction('audioFiles', 'readonly');
      const store = tx.objectStore('audioFiles');
      const req = store.getAll();
      req.onsuccess = () => resolve(req.result);
      req.onerror = e => reject(e.target.error);
    });
  }

  // Playlist persistence (only store id and name in localStorage)
  function loadPlaylistMeta() {
    const stored = localStorage.getItem('music-player-local-playlist');
    let loaded = stored ? JSON.parse(stored) : [];
    // Clean up: filter out entries with missing/invalid id
    loaded = loaded.filter(item => item && typeof item.id === 'string' && item.id.length > 0);
    playlist = loaded;
    savePlaylistMeta();
  }
  function savePlaylistMeta() {
    localStorage.setItem('music-player-local-playlist', JSON.stringify(playlist));
  }

  async function renderPlaylist() {
    playlistEl.innerHTML = '';
    for (let idx = 0; idx < playlist.length; idx++) {
      const item = playlist[idx];
      if (!item || !item.id) continue;
      const li = document.createElement('li');
      li.className = idx === currentIdx ? 'active' : '';
      li.setAttribute('draggable', 'true');
      li.dataset.idx = idx;
      li.innerHTML = `<span class="playlist-drag-handle"><i class="fa fa-bars"></i></span>
        ${item.name || 'Untitled'}
        <i class="fa fa-pencil" title="Edit"></i>
        <i class="fa fa-trash" title="Delete"></i>`;
      // Drag events
      const dragHandle = li.querySelector('.playlist-drag-handle');
      dragHandle.addEventListener('mousedown', e => { li.draggable = true; });
      dragHandle.addEventListener('touchstart', e => { li.draggable = true; });
      dragHandle.addEventListener('mouseup', e => { li.draggable = false; });
      dragHandle.addEventListener('touchend', e => { li.draggable = false; });
      li.addEventListener('dragstart', e => {
        li.classList.add('dragging');
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/plain', idx);
      });
      li.addEventListener('dragend', e => {
        li.classList.remove('dragging');
        li.draggable = false;
      });
      li.addEventListener('dragover', e => { e.preventDefault(); });
      li.addEventListener('drop', e => {
        e.preventDefault();
        const fromIdx = parseInt(e.dataTransfer.getData('text/plain'));
        const toIdx = idx;
        if (fromIdx !== toIdx) {
          const moved = playlist.splice(fromIdx, 1)[0];
          playlist.splice(toIdx, 0, moved);
          savePlaylistMeta();
          renderPlaylist();
        }
      });
      li.addEventListener('click', () => {
        if (idx !== currentIdx) {
          currentIdx = idx;
          loadSong(idx);
        }
      });
      li.querySelector('.fa-trash').addEventListener('click', async (e) => {
        e.stopPropagation();
        if (window.confirm('Remove this song from playlist?')) {
          if (objectUrls[item.id]) {
            URL.revokeObjectURL(objectUrls[item.id]);
            delete objectUrls[item.id];
          }
          await deleteFileFromDB(item.id);
          playlist.splice(idx, 1);
          if (currentIdx >= playlist.length) currentIdx = playlist.length - 1;
          savePlaylistMeta();
          renderPlaylist();
          if (playlist.length > 0) loadSong(currentIdx);
          else clearPlayer();
        }
      });
      li.querySelector('.fa-pencil').addEventListener('click', (e) => {
        e.stopPropagation();
        const newTitle = prompt('Edit song title:', item.name || '');
        if (newTitle !== null) {
          playlist[idx].name = newTitle;
          savePlaylistMeta();
          renderPlaylist();
        }
      });
      playlistEl.appendChild(li);
    }
  }

  function clearPlayer() {
    audio.src = '';
    songTitle.textContent = 'No Song';
    progressBar.value = 0;
    currentTime.textContent = '0:00';
    duration.textContent = '0:00';
    isPlaying = false;
    playBtn.innerHTML = '<i class="fa fa-play"></i>';
    if (progressInterval) clearInterval(progressInterval);
  }

  async function loadSong(idx) {
    if (!playlist[idx] || !playlist[idx].id) return clearPlayer();
    songTitle.textContent = playlist[idx].name || 'Untitled';
    const id = playlist[idx].id;
    if (!objectUrls[id]) {
      const entry = await getFileFromDB(id);
      if (!entry) return clearPlayer();
      objectUrls[id] = URL.createObjectURL(entry.file);
    }
    audio.src = objectUrls[id];
    audio.load();
    if (isPlaying) audio.play();
    renderPlaylist();
  }

  function play() {
    if (!playlist[currentIdx]) return;
    audio.play();
    isPlaying = true;
    playBtn.innerHTML = '<i class="fa fa-pause"></i>';
    if (progressInterval) clearInterval(progressInterval);
    progressInterval = setInterval(updateProgress, 500);
  }
  function pause() {
    audio.pause();
    isPlaying = false;
    playBtn.innerHTML = '<i class="fa fa-play"></i>';
    if (progressInterval) clearInterval(progressInterval);
  }
  function prev() {
    if (playlist.length === 0) return;
    currentIdx = (currentIdx - 1 + playlist.length) % playlist.length;
    loadSong(currentIdx);
    if (isPlaying) play();
  }
  function next() {
    if (playlist.length === 0) return;
    const nextIdx = getNextIndex();
    if (nextIdx === -1) {
      pause();
      audio.currentTime = 0;
      updateProgress();
      return;
    }
    currentIdx = nextIdx;
    loadSong(currentIdx);
    if (isPlaying) play();
  }
  function setVolume(val) {
    audio.volume = val / 100;
    volumeBar.value = val;
    volumeLabel.textContent = val + '%';
  }
  function updateProgress() {
    if (!audio.src) return;
    const cur = audio.currentTime || 0;
    const dur = audio.duration || 0;
    progressBar.value = dur ? (cur / dur) * 100 : 0;
    currentTime.textContent = formatTime(cur);
    duration.textContent = formatTime(dur);
  }
  function formatTime(sec) {
    sec = Math.floor(sec);
    const m = Math.floor(sec / 60);
    const s = sec % 60;
    return m + ':' + (s < 10 ? '0' : '') + s;
  }
  function seek(val) {
    if (!audio.src) return;
    const dur = audio.duration || 0;
    audio.currentTime = (val / 100) * dur;
  }

  // Modal open/close
  function openModal() {
    modal.style.display = 'block';
    setTimeout(() => { modal.style.opacity = 1; }, 10);
    if (playlist.length > 0) loadSong(currentIdx);
  }
  function closeModal() {
    modal.style.opacity = 0;
    setTimeout(() => { modal.style.display = 'none'; clearPlayer(); }, 200);
  }

  // Add songs from file input
  async function addSongsFromFiles(files) {
    for (let i = 0; i < files.length; i++) {
      const file = files[i];
      const id = crypto.randomUUID();
      await addFileToDB(id, file.name, file);
      playlist.push({ id, name: file.name });
    }
    savePlaylistMeta();
    renderPlaylist();
    if (playlist.length === files.length) {
      currentIdx = 0;
      loadSong(0);
    }
  }

  // Sort playlist alphabetically
  function sortPlaylist() {
    playlist.sort((a, b) => (a.name || '').localeCompare(b.name || ''));
    savePlaylistMeta();
    renderPlaylist();
  }

  // Shuffle and repeat logic
  function updateShuffleUI() {
    if (shuffleMode) shuffleBtn.classList.add('active');
    else shuffleBtn.classList.remove('active');
  }
  function updateRepeatUI() {
    repeatBtn.classList.remove('active', 'repeat-all', 'repeat-one');
    if (repeatMode === 1) repeatBtn.classList.add('active', 'repeat-all');
    if (repeatMode === 2) repeatBtn.classList.add('active', 'repeat-one');
  }
  function getNextIndex() {
    if (repeatMode === 2) return currentIdx; // repeat one
    if (shuffleMode) {
      if (!shuffledOrder.length || shuffledOrder.length !== playlist.length) {
        shuffledOrder = playlist.map((_, i) => i);
        for (let i = shuffledOrder.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [shuffledOrder[i], shuffledOrder[j]] = [shuffledOrder[j], shuffledOrder[i]];
        }
      }
      const idxInShuffle = shuffledOrder.indexOf(currentIdx);
      const nextIdx = (idxInShuffle + 1) % shuffledOrder.length;
      return shuffledOrder[nextIdx];
    }
    // Normal next
    if (currentIdx + 1 < playlist.length) return currentIdx + 1;
    if (repeatMode === 1) return 0; // repeat all
    return -1;
  }

  // Drag functionality
  function onDragStart(e) {
    if (modal.classList.contains('minimized')) return;
    isDragging = true;
    const rect = modal.getBoundingClientRect();
    dragOffsetX = (e.type === 'touchstart' ? e.touches[0].clientX : e.clientX) - rect.left;
    dragOffsetY = (e.type === 'touchstart' ? e.touches[0].clientY : e.clientY) - rect.top;
    document.addEventListener('mousemove', onDragMove);
    document.addEventListener('mouseup', onDragEnd);
    document.addEventListener('touchmove', onDragMove);
    document.addEventListener('touchend', onDragEnd);
  }
  function onDragMove(e) {
    if (!isDragging) return;
    let x = (e.type === 'touchmove' ? e.touches[0].clientX : e.clientX) - dragOffsetX;
    let y = (e.type === 'touchmove' ? e.touches[0].clientY : e.clientY) - dragOffsetY;
    const w = modal.offsetWidth, h = modal.offsetHeight;
    x = Math.max(0, Math.min(window.innerWidth - w, x));
    y = Math.max(0, Math.min(window.innerHeight - h, y));
    modal.style.left = x + 'px';
    modal.style.top = y + 'px';
    modal.style.right = 'auto';
    modal.style.bottom = 'auto';
    modal.style.transform = 'none';
    lastPosition = { x, y };
  }
  function onDragEnd() {
    isDragging = false;
    document.removeEventListener('mousemove', onDragMove);
    document.removeEventListener('mouseup', onDragEnd);
    document.removeEventListener('touchmove', onDragMove);
    document.removeEventListener('touchend', onDragEnd);
  }

  // Minimize/Restore
  function minimizeModal() {
    modal.classList.add('minimized');
    modal.classList.remove('maximized');
    maximizeBtn.style.display = 'inline-flex';
    minimizeBtn.style.display = 'none';
    modal.style.left = 'auto';
    modal.style.top = 'auto';
    modal.style.right = '2rem';
    modal.style.bottom = '2rem';
    modal.style.transform = 'none';
  }
  function restoreModal() {
    modal.classList.remove('minimized');
    modal.classList.remove('maximized');
    maximizeBtn.style.display = 'none';
    minimizeBtn.style.display = 'inline-flex';
    modal.style.width = '';
    modal.style.height = '';
    modal.style.left = '';
    modal.style.top = '';
    modal.style.right = '';
    modal.style.bottom = '';
    modal.style.transform = '';
  }

  // DOMContentLoaded
  window.addEventListener('DOMContentLoaded', async function() {
    modal = document.getElementById('music-player-modal');
    openBtn = document.getElementById('open-music-player');
    closeBtn = document.getElementById('close-music-player');
    songTitle = document.getElementById('music-player-song-title');
    progressBar = document.getElementById('music-player-progress-bar');
    currentTime = document.getElementById('music-player-current-time');
    duration = document.getElementById('music-player-duration');
    playBtn = document.getElementById('music-player-play');
    prevBtn = document.getElementById('music-player-prev');
    nextBtn = document.getElementById('music-player-next');
    volumeBar = document.getElementById('music-player-volume-bar');
    volumeLabel = document.getElementById('music-player-volume-label');
    fileInput = document.getElementById('music-player-file-input');
    playlistEl = document.getElementById('music-player-playlist');
    sortBtn = document.getElementById('music-player-sort');
    audio = document.getElementById('music-player-audio');
    minimizeBtn = document.getElementById('music-player-minimize');
    maximizeBtn = document.getElementById('music-player-maximize');
    shuffleBtn = document.getElementById('music-player-shuffle');
    repeatBtn = document.getElementById('music-player-repeat');

    db = await openDB();
    loadPlaylistMeta();
    // On load, build object URLs for all files in playlist
    for (const item of playlist) {
      if (!objectUrls[item.id]) {
        const entry = await getFileFromDB(item.id);
        if (entry) objectUrls[item.id] = URL.createObjectURL(entry.file);
      }
    }
    renderPlaylist();

    openBtn.addEventListener('click', openModal);
    closeBtn.addEventListener('click', closeModal);
    playBtn.addEventListener('click', function() { if (isPlaying) pause(); else play(); });
    prevBtn.addEventListener('click', prev);
    nextBtn.addEventListener('click', next);
    volumeBar.addEventListener('input', function() { setVolume(Number(this.value)); });
    progressBar.addEventListener('input', function() { seek(Number(this.value)); });
    sortBtn.addEventListener('click', sortPlaylist);
    fileInput.addEventListener('change', function() { addSongsFromFiles(this.files); this.value = ''; });
    audio.addEventListener('ended', next);
    audio.addEventListener('loadedmetadata', updateProgress);
    audio.addEventListener('timeupdate', updateProgress);
    setVolume(Number(volumeBar.value));

    // Drag/Minimize/Maximize events (unchanged)
    const header = modal.querySelector('.music-player-header');
    header.addEventListener('mousedown', onDragStart);
    header.addEventListener('touchstart', onDragStart);
    minimizeBtn.addEventListener('click', minimizeModal);
    maximizeBtn.addEventListener('click', restoreModal);
    header.addEventListener('click', function(e) {
      if (modal.classList.contains('minimized') && !e.target.closest('button')) {
        restoreModal();
      }
    });

    shuffleBtn.addEventListener('click', function() {
      shuffleMode = !shuffleMode;
      shuffledOrder = [];
      updateShuffleUI();
    });
    repeatBtn.addEventListener('click', function() {
      repeatMode = (repeatMode + 1) % 3;
      updateRepeatUI();
    });
    updateShuffleUI();
    updateRepeatUI();
  });
})();

// --- Knowledge Base Modal Functionality ---
(function() {
  let kbModal, kbOpenBtn, kbCloseBtn, kbMinimizeBtn, kbMaximizeBtn;
  let isDragging = false, dragOffsetX = 0, dragOffsetY = 0, lastPosition = null;
  let tabsList, addTabBtn, tableContainer;
  let tabs = [], currentTabId = null;

  // Storage helpers
  function saveTabs() {
    chrome.storage.local.set({ knowledgeBaseTabs: tabs });
  }
  function loadTabs(callback) {
    chrome.storage.local.get(['knowledgeBaseTabs'], function(result) {
      tabs = result.knowledgeBaseTabs || [
        { id: 'tab-' + Date.now(), name: 'Double-click to rename', rows: [] }
      ];
      if (!currentTabId || !tabs.find(t => t.id === currentTabId)) {
        currentTabId = tabs[0].id;
      }
      if (callback) callback();
    });
  }

  // Tab UI
  function renderTabs() {
    tabsList.innerHTML = '';
    tabs.forEach(tab => {
      const tabBtn = document.createElement('div');
      tabBtn.className = 'knowledge-base-tab' + (tab.id === currentTabId ? ' active' : '');
      tabBtn.textContent = tab.name;
      tabBtn.title = 'Double-click to rename';
      tabBtn.addEventListener('click', () => {
        currentTabId = tab.id;
        renderTabs();
        renderTable();
      });
      tabBtn.addEventListener('dblclick', () => {
        const newName = prompt('Rename tab:', tab.name);
        if (newName && newName.trim()) {
          tab.name = newName.trim();
          saveTabs();
          renderTabs();
        }
      });
      // Delete tab button (if more than 1 tab)
      if (tabs.length > 1) {
        const delBtn = document.createElement('button');
        delBtn.className = 'knowledge-base-tab-delete';
        delBtn.innerHTML = '<i class="fa fa-times"></i>';
        delBtn.title = 'Delete tab';
        delBtn.addEventListener('click', e => {
          e.stopPropagation();
          if (confirm('Delete this tab and all its data?')) {
            const idx = tabs.findIndex(t => t.id === tab.id);
            tabs.splice(idx, 1);
            if (currentTabId === tab.id) {
              currentTabId = tabs[0].id;
            }
            saveTabs();
            renderTabs();
            renderTable();
          }
        });
        tabBtn.appendChild(delBtn);
      }
      tabsList.appendChild(tabBtn);
    });
  }

  // Table UI
  function renderTable() {
    const tab = tabs.find(t => t.id === currentTabId);
    if (!tab) return;
    tableContainer.innerHTML = '';
    const table = document.createElement('table');
    table.className = 'knowledge-base-table';
    const thead = document.createElement('thead');
    thead.innerHTML = '<tr><th>Title</th><th>Details</th><th>Source</th><th></th></tr>';
    table.appendChild(thead);
    const tbody = document.createElement('tbody');
    tab.rows.forEach((row, idx) => {
      const tr = document.createElement('tr');
      ['title', 'details', 'source'].forEach((col, colIdx) => {
        const td = document.createElement('td');
        td.contentEditable = 'true';
        td.className = 'kb-cell kb-' + col;
        td.innerText = row[col] || '';
        td.addEventListener('blur', () => {
          row[col] = td.innerText.trim();
          saveTabs();
          if (col === 'source') renderTable(); // re-render for linkify
        });
        if (col === 'source' && row.source && isUrl(row.source)) {
          td.innerHTML = `<a href="${row.source}" target="_blank">${row.source}</a>`;
        }
        tr.appendChild(td);
      });
      // Delete row button
      const tdDel = document.createElement('td');
      const delBtn = document.createElement('button');
      delBtn.className = 'kb-row-delete';
      delBtn.innerHTML = '<i class="fa fa-trash"></i>';
      delBtn.title = 'Delete row';
      delBtn.addEventListener('click', () => {
        tab.rows.splice(idx, 1);
        saveTabs();
        renderTable();
      });
      tdDel.appendChild(delBtn);
      tr.appendChild(tdDel);
      tbody.appendChild(tr);
    });
    table.appendChild(tbody);
    // Add row button
    const tfoot = document.createElement('tfoot');
    const trAdd = document.createElement('tr');
    const tdAdd = document.createElement('td');
    tdAdd.colSpan = 4;
    const addBtn = document.createElement('button');
    addBtn.className = 'kb-row-add';
    addBtn.innerHTML = '<i class="fa fa-plus"></i> Add Row';
    addBtn.addEventListener('click', () => {
      tab.rows.push({ title: '', details: '', source: '' });
      saveTabs();
      renderTable();
    });
    tdAdd.appendChild(addBtn);
    trAdd.appendChild(tdAdd);
    tfoot.appendChild(trAdd);
    table.appendChild(tfoot);
    tableContainer.appendChild(table);
  }

  function isUrl(str) {
    return /^https?:\/\//i.test(str) || /^www\./i.test(str);
  }

  // Add tab
  function addTab() {
    const name = prompt('Tab name?', 'New Tab');
    if (!name || !name.trim()) return;
    const id = 'tab-' + Date.now() + '-' + Math.floor(Math.random()*10000);
    tabs.push({ id, name: name.trim(), rows: [] });
    currentTabId = id;
    saveTabs();
    renderTabs();
    renderTable();
  }

  // Modal open/close/drag/minimize/maximize (unique names)
  function openKnowledgeBaseModal() {
    kbModal.style.display = 'block';
    setTimeout(() => { kbModal.style.opacity = 1; }, 10);
  }
  function closeKnowledgeBaseModal() {
    kbModal.style.opacity = 0;
    setTimeout(() => { kbModal.style.display = 'none'; }, 200);
  }
  function minimizeKnowledgeBaseModal() {
    kbModal.classList.add('minimized');
    kbModal.classList.remove('maximized');
    kbMaximizeBtn.style.display = 'inline-flex';
    kbMinimizeBtn.style.display = 'none';
    kbModal.style.left = 'auto';
    kbModal.style.top = 'auto';
    kbModal.style.right = '2rem';
    kbModal.style.bottom = '2rem';
    kbModal.style.transform = 'none';
  }
  function restoreKnowledgeBaseModal() {
    kbModal.classList.remove('minimized');
    kbModal.classList.remove('maximized');
    kbMaximizeBtn.style.display = 'none';
    kbMinimizeBtn.style.display = 'inline-flex';
    kbModal.style.width = '';
    kbModal.style.height = '';
    kbModal.style.left = '';
    kbModal.style.top = '';
    kbModal.style.right = '';
    kbModal.style.bottom = '';
    kbModal.style.transform = '';
  }
  function onKnowledgeBaseDragStart(e) {
    if (kbModal.classList.contains('minimized')) return;
    isDragging = true;
    const rect = kbModal.getBoundingClientRect();
    dragOffsetX = (e.type === 'touchstart' ? e.touches[0].clientX : e.clientX) - rect.left;
    dragOffsetY = (e.type === 'touchstart' ? e.touches[0].clientY : e.clientY) - rect.top;
    document.addEventListener('mousemove', onKnowledgeBaseDragMove);
    document.addEventListener('mouseup', onKnowledgeBaseDragEnd);
    document.addEventListener('touchmove', onKnowledgeBaseDragMove);
    document.addEventListener('touchend', onKnowledgeBaseDragEnd);
  }
  function onKnowledgeBaseDragMove(e) {
    if (!isDragging) return;
    let x = (e.type === 'touchmove' ? e.touches[0].clientX : e.clientX) - dragOffsetX;
    let y = (e.type === 'touchmove' ? e.touches[0].clientY : e.clientY) - dragOffsetY;
    const w = kbModal.offsetWidth, h = kbModal.offsetHeight;
    x = Math.max(0, Math.min(window.innerWidth - w, x));
    y = Math.max(0, Math.min(window.innerHeight - h, y));
    kbModal.style.left = x + 'px';
    kbModal.style.top = y + 'px';
    kbModal.style.right = 'auto';
    kbModal.style.bottom = 'auto';
    kbModal.style.transform = 'none';
    lastPosition = { x, y };
  }
  function onKnowledgeBaseDragEnd() {
    isDragging = false;
    document.removeEventListener('mousemove', onKnowledgeBaseDragMove);
    document.removeEventListener('mouseup', onKnowledgeBaseDragEnd);
    document.removeEventListener('touchmove', onKnowledgeBaseDragMove);
    document.removeEventListener('touchend', onKnowledgeBaseDragEnd);
  }

  window.addEventListener('DOMContentLoaded', function() {
    kbModal = document.getElementById('knowledge-base-modal');
    kbOpenBtn = document.getElementById('open-knowledge-base');
    kbCloseBtn = document.getElementById('close-knowledge-base');
    kbMinimizeBtn = document.getElementById('knowledge-base-minimize');
    kbMaximizeBtn = document.getElementById('knowledge-base-maximize');
    tabsList = document.getElementById('knowledge-base-tabs-list');
    addTabBtn = document.getElementById('add-knowledge-base-tab');
    tableContainer = document.getElementById('knowledge-base-table-container');
    if (!kbModal || !kbOpenBtn || !kbCloseBtn || !kbMinimizeBtn || !kbMaximizeBtn || !tabsList || !addTabBtn || !tableContainer) return;
    kbOpenBtn.addEventListener('click', openKnowledgeBaseModal);
    kbCloseBtn.addEventListener('click', closeKnowledgeBaseModal);
    kbMinimizeBtn.addEventListener('click', minimizeKnowledgeBaseModal);
    kbMaximizeBtn.addEventListener('click', restoreKnowledgeBaseModal);
    const header = kbModal.querySelector('.knowledge-base-header');
    header.addEventListener('mousedown', onKnowledgeBaseDragStart);
    header.addEventListener('touchstart', onKnowledgeBaseDragStart);
    header.addEventListener('click', function(e) {
      if (kbModal.classList.contains('minimized') && !e.target.closest('button')) {
        restoreKnowledgeBaseModal();
      }
    });
    addTabBtn.addEventListener('click', addTab);
    loadTabs(function() {
      renderTabs();
      renderTable();
    });
  });
})();

// Help Modal Functionality
const helpButton = document.querySelector('.help-button');
const helpModal = document.getElementById('help-modal');
const helpModalClose = document.querySelector('.help-modal-close');

helpButton.addEventListener('click', () => {
    helpModal.style.display = 'block';
    document.body.style.overflow = 'hidden';
});

helpModalClose.addEventListener('click', () => {
    helpModal.style.display = 'none';
    document.body.style.overflow = 'auto';
});

helpModal.addEventListener('click', (e) => {
    if (e.target === helpModal) {
        helpModal.style.display = 'none';
        document.body.style.overflow = 'auto';
    }
});